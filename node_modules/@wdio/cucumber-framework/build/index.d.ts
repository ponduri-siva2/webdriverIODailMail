/// <reference types="node" />
import { EventEmitter } from 'node:events';
import * as Cucumber from '@cucumber/cucumber';
import type { CucumberOptions, HookFunctionExtension as HookFunctionExtensionImport } from './types.js';
import type { GherkinDocument } from '@cucumber/messages';
import type { Capabilities, Options } from '@wdio/types';
import type { SupportCodeLibraryBuilder } from '@cucumber/cucumber/lib/support_code_library_builder/index.js';
import { DataTable, World } from '@cucumber/cucumber';
export declare const FILE_PROTOCOL = "file://";
declare const After: (<WorldType = Cucumber.IWorld<any>>(code: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").TestCaseHookFunction<WorldType>) => void) & (<WorldType_1 = Cucumber.IWorld<any>>(tags: string, code: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").TestCaseHookFunction<WorldType_1>) => void) & (<WorldType_2 = Cucumber.IWorld<any>>(options: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").IDefineTestCaseHookOptions, code: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").TestCaseHookFunction<WorldType_2>) => void), AfterAll: ((code: Function) => void) & ((options: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").IDefineTestRunHookOptions, code: Function) => void), AfterStep: (<WorldType = Cucumber.IWorld<any>>(code: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").TestStepHookFunction<WorldType>) => void) & (<WorldType_1 = Cucumber.IWorld<any>>(tags: string, code: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").TestStepHookFunction<WorldType_1>) => void) & (<WorldType_2 = Cucumber.IWorld<any>>(options: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").IDefineTestStepHookOptions, code: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").TestStepHookFunction<WorldType_2>) => void), Before: (<WorldType = Cucumber.IWorld<any>>(code: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").TestCaseHookFunction<WorldType>) => void) & (<WorldType_1 = Cucumber.IWorld<any>>(tags: string, code: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").TestCaseHookFunction<WorldType_1>) => void) & (<WorldType_2 = Cucumber.IWorld<any>>(options: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").IDefineTestCaseHookOptions, code: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").TestCaseHookFunction<WorldType_2>) => void), BeforeAll: ((code: Function) => void) & ((options: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").IDefineTestRunHookOptions, code: Function) => void), BeforeStep: (<WorldType = Cucumber.IWorld<any>>(code: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").TestStepHookFunction<WorldType>) => void) & (<WorldType_1 = Cucumber.IWorld<any>>(tags: string, code: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").TestStepHookFunction<WorldType_1>) => void) & (<WorldType_2 = Cucumber.IWorld<any>>(options: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").IDefineTestStepHookOptions, code: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").TestStepHookFunction<WorldType_2>) => void), Given: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").IDefineStep, When: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").IDefineStep, Then: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").IDefineStep, setDefaultTimeout: (milliseconds: number) => void, setDefinitionFunctionWrapper: (fn: Function) => void, setWorldConstructor: (fn: any) => void, defineParameterType: (options: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").IParameterTypeDefinition<any>) => void, defineStep: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").IDefineStep;
declare class CucumberAdapter {
    private _cid;
    private _config;
    private _specs;
    private _capabilities;
    private _reporter;
    private _eventEmitter;
    private _generateSkipTags;
    private _cucumberFormatter;
    private _cwd;
    private _newId;
    private _cucumberOpts;
    private _hasTests;
    private gherkinParser;
    constructor(_cid: string, _config: Options.Testrunner, _specs: string[], _capabilities: Capabilities.RemoteCapability, _reporter: EventEmitter, _eventEmitter: EventEmitter, _generateSkipTags?: boolean, _cucumberFormatter?: string);
    readFiles(filePaths?: Options.Testrunner['specs']): (string | string[])[];
    getGherkinDocuments(files?: Options.Testrunner['specs']): (GherkinDocument | GherkinDocument[])[];
    generateDynamicSkipTags(): string[];
    init(): Promise<this>;
    hasTests(): boolean;
    run(): Promise<number | undefined>;
    /**
     * Transpilation https://github.com/cucumber/cucumber-js/blob/master/docs/cli.md#transpilation
     * Usage: `['module']`
     * we extend it a bit with ability to init and pass configuration to modules.
     * Pass an array with path to module and its configuration instead:
     * Usage: `[['module', {}]]`
     * Or pass your own function
     * Usage: `[() => { require('@babel/register')({ ignore: [] }) }]`
     */
    registerRequiredModules(): Promise<void[]>;
    loadFilesWithType(fileList: string[]): Promise<string[]>;
    loadAndRefreshModule(modules: string[]): Promise<any[]>;
    loadFiles(): Promise<void>;
    /**
     * set `beforeFeature`, `afterFeature`, `beforeScenario`, `afterScenario`, 'beforeStep', 'afterStep'
     * @param {object} config config
     */
    addWdioHooksAndWrapSteps(config: Options.Testrunner, supportCodeLibraryBuilder: SupportCodeLibraryBuilder): void;
}
/**
 * Publishes a Cucumber report to a specified URL using NDJSON files from a directory.
 * @async
 * @param {string} cucumberMessageDir - The directory path that holds Cucumber NDJSON files.
 * @returns {Promise<void>} - A Promise that resolves when the report is successfully published.
 * @throws {Error} - Throws an error if there are issues with file reading or the publishing process.
 */
declare const publishCucumberReport: (cucumberMessageDir: string) => Promise<void>;
declare const adapterFactory: {
    init?: Function;
};
export default adapterFactory;
export { CucumberAdapter, adapterFactory, After, AfterAll, AfterStep, Before, BeforeAll, BeforeStep, Given, When, Then, DataTable, World, setDefaultTimeout, setDefinitionFunctionWrapper, setWorldConstructor, defineParameterType, defineStep, publishCucumberReport };
declare global {
    namespace WebdriverIO {
        interface CucumberOpts extends CucumberOptions {
        }
        interface HookFunctionExtension extends HookFunctionExtensionImport {
        }
    }
}
//# sourceMappingURL=index.d.ts.map